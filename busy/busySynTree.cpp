// This file was automatically generated by EbnfStudio; don't modify it!
#include "busySynTree.h"
using namespace busy;

SynTree::SynTree(quint16 r, const Token& t ):d_tok(r){
	d_tok.d_lineNr = t.d_lineNr;
	d_tok.d_colNr = t.d_colNr;
	d_tok.d_sourcePath = t.d_sourcePath;
}

const char* SynTree::rToStr( quint16 r ) {
	switch(r) {
		case R_AddOperator: return "AddOperator";
		case R_Busy: return "Busy";
		case R_ExpList: return "ExpList";
		case R_MulOperator: return "MulOperator";
		case R_SimpleExpression: return "SimpleExpression";
		case R_Submodule: return "Submodule";
		case R_assigOrCall: return "assigOrCall";
		case R_assignment: return "assignment";
		case R_block: return "block";
		case R_body: return "body";
		case R_call: return "call";
		case R_classdecl: return "classdecl";
		case R_condition: return "condition";
		case R_constructor: return "constructor";
		case R_declaration: return "declaration";
		case R_designator: return "designator";
		case R_enumdecl: return "enumdecl";
		case R_expression: return "expression";
		case R_factor: return "factor";
		case R_fielddecl: return "fielddecl";
		case R_identdef: return "identdef";
		case R_initializer: return "initializer";
		case R_list: return "list";
		case R_macrodef: return "macrodef";
		case R_paramList: return "paramList";
		case R_paramValue: return "paramValue";
		case R_relation: return "relation";
		case R_statement: return "statement";
		case R_term: return "term";
		case R_tokens_: return "tokens";
		case R_typedecl: return "typedecl";
		case R_typeref: return "typeref";
		case R_vardecl: return "vardecl";
	default: if(r<R_First) return tokenTypeName(r); else return "";
}
}
